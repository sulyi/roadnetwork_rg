"""Abstract classes for generating point process and partial implementation of them"""

from typing import Generator, Iterator, Tuple, TypeVar, Union

import numpy as np

T = TypeVar('T', bound=Tuple[int, ...])
"""It is a generic type of :class:`PointProcess`, bounded by :class:`tuple` [:class:`int`, ...]."""


# Abstract classes


class IntensityFunction:
    """It is an abstract class that provides following interface: :attr:`rate`, :meth:`is_accepted`
    used by :meth:`PointProcess.__next__` method.
    """

    @property
    def rate(self) -> float:
        """It is the expected number of points generated.

        :rtype: :class:`float`
        """
        raise NotImplementedError

    def is_accepted(self, value: T, threshold: float) -> bool:
        """Checks if a value is accepted by thinning of the point process.

        :param value: It is the candidate, that is either accepted or not.
        :type value: :data:`.T`
        :param threshold: It is a probability, that decides if candidate is accepted.
        :type threshold: :class:`float`
        :return: Result of thinning process.
        :rtype: :class:`bool`
        """
        raise NotImplementedError


RateType = Union[int, float, IntensityFunction]
"""It is the type of :attr:`~PointProcess.rate` attribute of :class:`PointProcess`."""


class PointProcess(Iterator[T]):
    """It is an abstract class for implementing point processes.

    It is a subclass of :class:`~collections.abc.Iterator` [:const:`T`] that represents a stream of
    :const:`T` type points generated by a point process. The a generic :const:`T` type is on
    instantiation.

    In order to simulate a point process :meth:`_generate` should be implemented in a subclass.
    """

    def __new__(cls, rate: RateType, size: T, seed: int) -> Iterator:
        """Constructs a new iterator instance.

        Checks the arguments first.

        :param rate: It should be non-negative, (if :class:`IntensityFunction` it's
            :attr:`~IntensityFunction.rate` attribute is used).
        :type rate: :const:`RateType`
        :param size: All numbers should be non-negative.
        :type size: :const:`T`
        :param seed: Has no other limit than its type.
        :type seed: :class:`int`
        :return: The new instance.
        :rtype: :class:`~collections.abc.Iterator`
        """
        if (not isinstance(size, tuple) or
                any(not isinstance(dim, int) for dim in size)):
            raise TypeError("Argument 'size' should be a tuple of integer numbers, not '%s'" %
                            type(size).__name__)
        if any(dim <= 0 for dim in size):
            raise ValueError("Argument 'size' should be positive")

        if not isinstance(rate, (int, float, IntensityFunction)):
            raise TypeError("Argument 'rate' should be a number or %s, not '%s'" %
                            IntensityFunction.__name__, type(rate).__name__)
        if ((isinstance(rate, (int, float)) and rate <= 0) or
                (isinstance(rate, IntensityFunction) and rate.rate <= 0)):
            raise ValueError("Argument 'rate' should be positive")

        if not isinstance(seed, int):
            raise TypeError("Argument 'seed' should be integer number, not '%s'" %
                            type(seed).__name__)
        return super(PointProcess, cls).__new__(cls)

    def __init__(self, rate: RateType, size: T, seed: int) -> None:
        """Initializes a new iterator instance.

        A private :attr:`_next` generator that provides the stream of points, is set by
        :meth:`_generate`.

        :param rate:
            Non-homogenous processes need to have an :class:`IntensityFunction` object as the value
            of this parameter.
            Homogenous processes might have :class:`int` or :class:`float` type (or an
            :class:`IntensityFunction` that's :attr:`IntensityFunction.rate` is **1** constantly) as
            the value of this.
        :type rate: :const:`RateType`
        :param size:
            It is a :const:`T` type object that describes the dimensions of the bounding box
            in which points are generated.
        :type size: :const:`T`
        :param seed: Number used initializing private pRNG instance.
        :type seed: :class:`int`
        """

        self.rate = rate
        self.size = size

        self._rng = np.random.default_rng(seed)
        self._next = self._generator()

    def __next__(self) -> T:
        """It is the override of :meth:`iterator.__next__` method.

        :return: They are points from private generator.
        :rtype: :const:`T`
        """

        return next(self._next)

    def __iter__(self) -> Iterator[T]:
        """Override of :meth:`iterator.__iter__` method.

        :return: Its own ``self``.
        :rtype: :class:`~collections.abc.Iterator` [:const:`T`]
        """
        return self

    def _generator(self) -> Generator[T, None, None]:
        raise NotImplementedError


# Implementation


class MarkovChainMonteCarlo(PointProcess):
    """It is an implementation of Markov chain Monte Carlo method."""

    def _generator(self) -> Generator[T, None, None]:
        n = self._rng.poisson(self.rate.rate if isinstance(self.rate, IntensityFunction) else
                              self.rate)
        count = 0
        while count <= n:
            candidate = tuple(self._rng.integers([0] * len(self.size), self.size))
            if isinstance(self.rate, IntensityFunction):
                # non-homogeneous
                thinning = self._rng.uniform(0, 1)
                if self.rate.is_accepted(candidate, thinning):
                    count += 1
                    yield candidate
            else:
                # homogeneous
                count += 1
                yield candidate


class SpatialPoissonPointProcess(PointProcess):
    """It is an implementation spatial point process generation."""

    def _generator(self) -> Generator[T, None, None]:
        n = self._rng.poisson(self.rate.rate if isinstance(self.rate, IntensityFunction) else
                              self.rate)
        for _ in range(n):
            candidate = tuple(self._rng.integers([0] * len(self.size), self.size))
            if isinstance(self.rate, IntensityFunction):
                # non-homogeneous
                thinning = self._rng.uniform(0, 1)
                if self.rate.is_accepted(candidate, thinning):
                    yield candidate
            else:
                # homogeneous
                yield candidate
