"""A modified Dijkstra algorithm"""

from __future__ import annotations

import bisect
from dataclasses import dataclass
from typing import Dict, List, Sequence, Tuple, Union

from PIL import Image

from .common import PixelPath, PointType


@dataclass
class Node:
    """It is a private boilerplate used by :meth:`Pathfinder.shortest_paths`."""
    x: int
    y: int
    distance: float = float('inf')
    parent: Union[Tuple[int, int], None] = None
    open: bool = False


class Pathfinder:
    """It is a modified implementation of Dijkstra's algorithm.

    Performs a flood to find from a source node the shortest paths to a set of target nodes.
    """

    __neighbours = ((-1, -1, 2 ** .5), (0, -1, 1.), (1, -1, 2 ** .5),
                    (-1, 0, 1.), (1, 0, 1.),
                    (-1, 1, 2 ** .5), (0, 1, 1.), (1, 1, 2 ** .5))

    def __init__(self, graph: Image.Image, targets: Sequence[PointType, ...]):
        """Initializes the finder.

        :param graph: It is a height map generated by :meth:`.HeightMap.generate`.
        :type graph: :class:`PIL.Image.Image`
        :param targets: Nodes needed to be reached.
        :type targets: :class:`~typing.Sequence` [:data:`.PointType`, ...]
        """
        self._width, self._height = graph.size
        self._graph = list(graph.tobytes())
        self._targets = targets

    # FIXME: check optimization

    def shortest_paths(self, source_index: int) -> Dict[Tuple[PointType, PointType], PixelPath]:
        """Floods graph from source to find shortest paths to targets.

        :param source_index: Marks source among targets.
        :type source_index: :class:`int`
        :return: A dict, key is a pair of the end points, value is a path.
        :rtype: :class:`dict` [:class:`tuple` [:data:`.PointType`, :data:`.PointType`],
         :class:`.PixelPath`]
        """
        nodes = {(x, y): Node(x, y) for x in range(self._width) for y in range(self._height)}
        nodes[self._targets[source_index][:2]].distance = 0.
        nodes[self._targets[source_index][:2]].open = True

        new_nodes = [Node(*self._targets[source_index][:2], distance=0.)]
        new_distances = [0.]

        while new_nodes:
            node = new_nodes.pop(0)
            new_distances.pop(0)
            node.open = False
            u_value = self._graph[node.x + self._width * node.y]

            for d_x, d_y, h_cost in self.__neighbours:
                n_x, n_y = node.x + d_x, node.y + d_y
                if 0 <= n_x < self._width and 0 <= n_y < self._height:
                    v_cost = abs(u_value - self._graph[n_x + self._width * n_y])
                    alt = node.distance + v_cost + h_cost
                    if alt < nodes[n_x, n_y].distance:
                        if nodes[n_x, n_y].open:
                            index = new_nodes.index(
                                nodes[n_x, n_y],
                                bisect.bisect_left(new_distances, nodes[n_x, n_y].distance)
                            )
                            new_nodes.pop(index)
                            new_distances.pop(index)
                        nodes[n_x, n_y].distance = alt
                        nodes[n_x, n_y].parent = node.x, node.y
                        nodes[n_x, n_y].open = True
                        index = bisect.bisect(new_distances, alt)
                        new_distances.insert(index, alt)
                        new_nodes.insert(index, nodes[n_x, n_y])

        self._check_result(nodes, source_index)

        return {(self._targets[source_index], target): PixelPath(nodes[target[:2]].distance,
                                                                 self._backtrack(nodes, target[:2]))
                for target in self._targets[source_index + 1:]}

    def _check_result(self, nodes, source_index):
        if {node[:2] for node in self._targets[source_index:]}.difference(nodes.keys()):
            # NOTE: shouldn't be reachable anyway
            raise ArithmeticError("Couldn't be found a path to each node")

    @staticmethod
    def _backtrack(predecessors: Dict[Tuple[int, int]: Node],
                   current: Tuple[int, int]) -> List[Tuple[int, int], ...]:
        total_path = []
        while True:
            current = predecessors[current].parent
            if current is not None and predecessors[current].parent in predecessors:
                # None possible if multiple city in same node (one being the source)
                total_path.append(current)
                continue
            break
        total_path.reverse()
        return total_path
